var I=Object.defineProperty,Se=Object.prototype.hasOwnProperty,Ee=e=>I(e,"__esModule",{value:!0}),ke=(e,t)=>{if(Ee(e),typeof t=="object"||typeof t=="function")for(let r in t)!Se.call(e,r)&&r!=="default"&&I(e,r,{get:()=>t[r],enumerable:!0});return e},d=e=>e&&e.__esModule?e:ke(I({},"default",{value:e,enumerable:!0}),e);function q(e,t){let r=0;if(t===!0){let s=process.env.TERM||"";r=s&&["xterm","screen","vt100"].some(n=>s.indexOf(n)!=-1)?s.indexOf("256color")!=-1?8:4:2}else t!==!1&&e.isTTY&&(r=e.getColorDepth());return r}function H(e,t){return V(q(e,t),t)}function V(e,t){const r=i=>`[${i}m`,s=e>0||t?(i,o)=>{const a=r(i),l=r(o);return m=>a+m+l}:i=>o=>o,n=e>=8?(i,o,a)=>{let l="["+o+"m",m="["+a+"m";return b=>l+b+m}:e>0?(i,o,a)=>{let l="["+i+"m",m="["+a+"m";return b=>l+b+m}:(i,o,a)=>l=>l;return{_hint:t,ncolors:e,reset:t||e>0?"e[0m":"",bold:s("1","22"),italic:s("3","23"),underline:s("4","24"),inverse:s("7","27"),white:n("37","38;2;255;255;255","39"),grey:n("90","38;5;244","39"),black:n("30","38;5;16","39"),blue:n("34","38;5;75","39"),cyan:n("36","38;5;87","39"),green:n("32","38;5;84","39"),magenta:n("35","38;5;213","39"),purple:n("35","38;5;141","39"),pink:n("35","38;5;211","39"),red:n("31","38;2;255;110;80","39"),yellow:n("33","38;5;227","39"),lightyellow:n("93","38;5;229","39"),orange:n("33","38;5;215","39"),reconfigure(i,o){const a=q(i,o);return a!=this.ncolors&&o!=this._hint&&Object.assign(this,V(a,o)),this}}}const k=H(process.stdout),P=H(process.stderr);const w=d(require("fs")),p=d(require("path")),J=d(require("os")),Pe=d(require("perf_hooks")),X=d(require("util")),O=(e,t,r)=>JSON.stringify(e,r,t),_=Symbol("TYPE"),F=eval("require");function x(e,t){let r={colors:k.ncolors>0};return typeof t=="object"?r={...t}:t!==void 0&&(r.compact=!t),X.inspect(e,r)}function Te(e){const t=F.resolve(e);let r=p.dirname(p.resolve(t)),s=p.sep;for(;r!=s;){let n=p.join(r,"package.json");if(w.existsSync(n))return n;r=p.dirname(r)}throw new Error(`package.json not found for module ${e}`)}function Q(e){const t=Te(e);return Ce(t)}function Re(e,t){const r=require("vm");return r.runInNewContext("("+e+")",{},{filename:t,displayErrors:!0})}function Ce(e){return Re(w.readFileSync(e,"utf8"),e)}function Z(e){const t=J.homedir();return e=="~"?t:e.startsWith("~"+p.sep)?t+e.substr(1):e}const B=new Map,Ie=Symbol("isMemoized");function ee(e){return function(...r){let s=r.map(O).join("\0");if(!B.has(s)){const i=e(...r);return B.set(s,i),i}let n=B.get(s);return n&&typeof n=="object"&&(n[Ie]=!0),n}}const u=d(require("path")),W=(()=>{const e=process.env._,t=process.argv[1];if(!t)return e||process.argv[0];if(e&&!u.isAbsolute(e))return e;let r="";if(e){const s=u.basename(process.execPath);e.endsWith(u.sep+s)&&(r=s+" ")}if(t.startsWith(process.cwd())){let s=u.relative(process.cwd(),t);if(!s.startsWith("node_modules"+u.sep)&&s.indexOf(u.sep+"node_modules"+u.sep)==-1)return u.sep=="/"&&(s="./"+s),s}return r+u.basename(t)})();const te={version:"0.7.4",BuildOptions:new Set(["sourcemap","format","globalName","target","strict","minify","minifyWhitespace","minifyIdentifiers","minifySyntax","jsxFactory","jsxFragment","define","pure","color","logLevel","errorLimit","bundle","splitting","outfile","metafile","outdir","platform","external","loader","resolveExtensions","mainFields","write","tsconfig","outExtension","entryPoints","stdin"])},Je={BuildConfig:new Set(["entry","debug","watch","cwd","quiet","clear","tslint","onStart","onEnd","title","outfileMode","run","tsc","tsrules"])};const re=d(require("fs"));function Oe(e){let t="(not found)";try{t=Q("esbuild").version}catch(s){}let r=`If you think this is a bug in Estrella, please file an issue at:
  https://github.com/rsms/estrella/issues
Include the following information in the report along with the stack trace:
  estrella: v${VERSION} (esbuild v${te.version})
  esbuild:  v${t}`;return e&&(r+=`
  context:  ${e}`),r}function ne(e,t){Error.prepareStackTrace=void 0;try{if(T().installSourceMapSupport(),Error.prepareStackTrace!==ne)return Error.prepareStackTrace(e,t)}catch(r){}return e.stack||String(e)}function se(e,t){let r="",s="";(!e||typeof e!="object")&&(e=String(e));const n=(e.stack||"").match(/\n\s{2,}at /);n?(r=e.stack.substr(0,n.index),s=e.stack.substr(n.index+1)):r=e.message||String(e);let i=t=="unhandledRejection"?"promise rejection":"exception",o=P.red(`Unhandled ${i}: ${r}`);if(s){try{const a=T().getErrorSource(e);a&&(o+=`
${a}`)}catch(a){}o+=`
`+s}o+=`
`+Oe(),re.writeSync(process.stderr.fd,o+`
`),process.exit(2)}Error.prepareStackTrace=ne;process.on("uncaughtException",se);process.on("unhandledRejection",(e,t)=>{se(e||"PromiseRejection","unhandledRejection")});const oe=d(require("console"));var h;(function(e){e[e.Error=0]="Error",e[e.Warn=1]="Warn",e[e.Info=2]="Info",e[e.Debug=3]="Debug"})(h||(h={}));let v=console,$;const S=new class{constructor(){this.ERROR=0;this.WARN=1;this.INFO=2;this.DEBUG=3;this.level=2;this.infoOnce=ee(()=>S.info.bind(S));this.debug=Fe}error(...t){v.error(P.red(`${W}:`),...t)}warn(...t){S.level>=1&&v.error(P.magenta(`${W}:`),...t)}info(...t){S.level>=2&&v.log(...t)}get colorMode(){return $}set colorMode(t){if($===t)return;$=t,t===void 0?v=console:v=new oe.Console({stdout:process.stdout,stderr:process.stderr,colorMode:t})}};var y=S;function Fe(...e){if(S.level>=3){let t="";if(typeof e[0]=="function"&&(e[0]=e[0]()),e.length==0||e.length==1&&(e[0]===""||e[0]===void 0))return;v.log(k.bold(k.blue(`[DEBUG${t}]`)),...e)}}const ie=d(require("path"));let j=null;function T(){return j||(y.debug("loading debug module"),j=F(ie.join(__dirname,"debug.js"))),j}const Be=d(require("fs"));function ae(e){return e&&e.read}function le(e){return e&&e.write}const N=Buffer.allocUnsafe(0);function de(e){return e&&typeof e=="object"&&e[_]=="Reader"}function C(e){return e?new $e(e):We}function A(e){return e?{[_]:"Writer",stream:e}:je}var mt;const We=new class{constructor(){this[mt]="Reader"}_E(){return new Error("stream not readable")}get stream(){throw this._E()}[(mt=_,Symbol.asyncIterator)](){throw this._E()}read(){return Promise.reject(this._E())}};var gt,ue;const je=new(ue=class{constructor(){this[gt]="Writer"}_E(){return new Error("stream not writable")}get stream(){throw this._E()}},gt=_,ue);var ht;class $e{constructor(e){this[ht]="Reader";this._ended=!1;this.stream=e,e.pause(),e.once("end",()=>{this._ended=!0})}[(ht=_,Symbol.asyncIterator)](){return this.stream[Symbol.asyncIterator]()}async read(e,t){const r=this.stream;if(r.pause(),typeof e=="string")t=e,e=Number.MAX_SAFE_INTEGER;else if(e==null||e<0)e=Number.MAX_SAFE_INTEGER;else if(e==0)return t?"":N;if(r.readable){let o=r.read(this._ended?void 0:e);if(o)return t?o.toString(t):o}if(this._ended)return t?"":N;const s=[];let n=0;if(r.readable){const o=r.read();o&&(s.push(o),n+=o.length)}for(;n<e&&!this._ended;){await new Promise((a,l)=>{r.once("error",l),r.once("end",a),r.once("readable",a)});let o=r.read(e-n);o||(o=r.read()),o&&(s.push(o),n+=o.length)}const i=ce(s);return t?i.toString(t):i}}function ce(e,t){return e.length==0?N:e.length==1?e[0]:Buffer.concat(e,t)}function M(){const e=[];let t=0;const r=e.push;return e.push=s=>(t+=s.length,r.call(e,s)),e.buffer=()=>ce(e,t),e}async function*pe(e,t){let r=[],s=0;for await(const n of e){let i=0;for(;;){let o=n.indexOf(10,i);if(o==-1){if(i<n.length-1){const l=n.subarray(i);r.push(l),s+=l.length}break}o++;let a=n.subarray(i,o);s>0&&(a=Buffer.concat(r.concat(a),s+a.length),r.length=0,s=0),yield t?a.toString(t):a,i=o}}if(r.length>0){const n=Buffer.concat(r,s);yield t?n.toString(t):n}}function G(e){const t=T().libuv_errors;return t[e]||""}function fe(e,t,r){const s=setTimeout(()=>{const n=new Error("timeout");n.name="Timeout",r(n)},t);return e.then(n=>(clearTimeout(s),n),n=>{throw clearTimeout(s),n})}const f=d(require("fs")),me=d(require("child_process")),ge=d(require("stream"));function be(e,t,r){(!t||!Array.isArray(t))&&(t&&typeof t=="object"&&(r=t),t=[]),r||(r={});const s=new he(e,...t);for(let i in r)s[i]=r[i];const n=s.start();return r&&("stdin"in r||"stdout"in r||"stderr"in r||"extraFiles"in r)?[s,n]:s}const ye="process not started";class he{constructor(e,...t){this.dir="";this.env={...process.env};this.shell=!1;this.stdin=null;this.stdout=null;this.stderr=null;this.extraFiles=[];this.windowsHide=!0;this.process=null;this.running=!1;this.pid=0;this.exitCode=-1;this._resolve=()=>{};this._reject=()=>{};this._onerror=e=>{y.debug(()=>`${this} error:
${e.stack||e}`),this._reject(e)};this._onexit=(e,t)=>{const r=this;y.debug(()=>`${r} exited status=${e} signal=${t}`),r.running=!1,r.exitCode=e===null||t!==null?-1:e||0,r._resolve(r.exitCode)};this.command=e,this.args=t,this.promise=Promise.reject(new Error(ye)),this.promise.catch(r=>{})}start(){return null}run(e){return this.start(),this.wait(e)}output(e,t){this.stdout="pipe",this.stderr||(this.stderr="pipe");const{stdout:r,stderr:s}=this.start(),n=M(),i=M();return r.stream.on("data",o=>{n.push(o)}),s&&s.stream.on("data",o=>{i.push(o)}),this.wait(t||0).then(o=>{if(o!=0){let l="";const m=i.buffer();try{l=m.toString("utf8")}catch(b){l=m.toString("ascii")}throw l.length>0&&(l=`. stderr output:
`+l),new Error(`command exited with status ${o}${l}`)}const a=n.buffer();return e?a.toString(e):a})}wait(e,t){return e===void 0||e<=0?this.promise:this._waitTimeout(e,(r,s,n)=>(y.debug(()=>`${this} wait timeout reached; killing process`),r.message="Cmd.wait timeout",this.kill(t).then(()=>n(r))))}signal(e,t){const r=this._checkproc();if(t=="group")try{return process.kill(-r.pid,e),!0}catch(s){}return r.kill(e)}async kill(e="SIGTERM",t=500,r){const s=this._checkproc();return this.signal(e,r||"group")?t<=0?this.promise:this._waitTimeout(t,(n,i)=>(y.debug(()=>`${this} kill timeout reached; sending SIGKILL`),s.kill("SIGKILL"),this.promise.then(i))):s.exitCode||0}toString(){return this.process?`Cmd[${this.pid}]`:"Cmd"}_checkproc(){if(!this.process)throw new Error(ye);return this.process}_rejectAndKill(e){this._reject(e)}_waitTimeout(e,t){return new Promise((r,s)=>{let n=!1;return this.promise.then(i=>{n||r(i)}),fe(this.promise,e,i=>{n=!0,t(i,r,s)})})}}he.prototype.start=function(){const t=this;if(t.running)throw new Error("start() called while command is running");t.exitCode=-1,t.promise=new Promise((o,a)=>{t._resolve=o,t._reject=a});let r=null,s=null;t.stdin instanceof Buffer?r="pipe":de(t.stdin)?typeof t.stdin.stream.fd=="string"?r=t.stdin.stream:(r="pipe",s=t.stdin.stream):r=t.stdin;const n=me.spawn(t.command,t.args,{stdio:[r,t.stdout===process.stdout?1:t.stdout||"ignore",t.stderr===process.stderr?2:t.stderr?t.stderr:"ignore",...t.extraFiles],cwd:t.dir?Z(t.dir):void 0,env:t.env,shell:t.shell,windowsHide:t.windowsHide,detached:!0});if(n.pid===void 0){t.process=null,t.pid=0;const o=Ne(t);throw t._reject(o),o}if(t.running=!0,t.process=n,t.pid=n.pid,n.on("exit",t._onexit),n.on("error",t._reject),y.debug(()=>`${t} started (${x(t.command)})`),n.stdin)if(t.stdin instanceof Buffer){const o=new ge.PassThrough;o.end(t.stdin),o.pipe(n.stdin),n.stdin=null}else s&&(s.pipe(n.stdin),n.stdin=null);if(!n.stdin&&!n.stdout&&!n.stderr&&n.stdio.length<4)return null;const i={stdin:n.stdin?A(n.stdin):null,stdout:n.stdout?C(n.stdout):null,stderr:n.stderr?C(n.stderr):null,extraFiles:n.stdio.slice(3).map(o=>ae(o)?C(o):le(o)?A(o):null)};return i};function Ne(e){let t="",r="unspecified error";if(e.shell==!1){try{f.accessSync(e.dir,f.constants.R_OK|f.constants.X_OK);const n=f.statSync(e.command);(n.mode&f.constants.S_IFREG)==0?t="EACCES":t="EIO"}catch(n){t=n.code||"ENOENT"}r=G(t)||r}if(!t){try{f.accessSync(e.dir,f.constants.R_OK|f.constants.X_OK),t="EIO"}catch(n){t=n.code||"ENOENT"}r=G(t)||r,t&&(r=r+"; cmd.dir="+x(e.dir))}t||(t="UNKNOWN");const s=new Error(`failed to spawn process ${x(e.command)} (${t} ${r})`);return s.code=t,s}const D=d(require("assert")),L=d(require("os")),z=d(require("path")),Ae=require("child_process");process.chdir(__dirname);const Me=!!parseInt(process.env.ESTRELLA_TEST_VERBOSE),E=Me?console.log.bind(console):()=>{};function we(...e){console.error("FAIL",...e),process.exit(1)}async function _e(e,t){const r={...process.env,IGNORE_SIGTERM:"true",SPAWN_SUBPROCESSES:String(t)};e=="standard"&&(r.FORWARD_SIGTERM="true");const[s,{stdout:n}]=be(process.execPath,["program1.js"],{stdout:"pipe",stderr:"inherit",env:r});E(`startCmd ${x(s.command)} ${x(s.args)}`);let i=!1,o=0,a=[],l=null,m=0,b=0,U=null;const Y=c=>{if(s.signal(c,e),e=="standard")for(let g of a)process.kill(g,c)};for await(const c of pe(n,"utf8"))if(E("stdout>>",c.trimEnd()),!i)/mainproc\[\d+\] start/.test(c)&&(i=!0);else if(o<t){const g=c.match(/subproc\d+\[(\d+)\] waiting/);g&&(a.push(parseInt(g[1])),o++),o==t&&(E(`all subprocs launched. PIDs: ${a.join(",")} OK`),E("sending SIGTERM"),l=s.kill("SIGTERM",0,e),U=setTimeout(()=>{Y("SIGKILL"),we("did not finish within 1s")},1e3))}else if(!m||b<t){if(/mainproc\[\d+\] received and ignoring SIGTERM/.test(c)&&(i=!0),/subproc\d+\[\d+\] received and ignoring SIGTERM/.test(c)&&b++,i&&b==t){if(E("all subprocs acknowledge receiving SIGTERM. OK"),R)for(let g of a){const K=await xe(g);K.indexOf(z.basename(process.execPath))==-1&&console.warn(`subproc [${g}] not found.
getProcessInfoForPID returned:
${K}`)}Y("SIGINT");break}}else we("received unexpected command output:",[c]),SIGKILL_all();const ve=await l;if(clearTimeout(U),R)for(let c of a){const g=await xe(c);g.indexOf(z.basename(process.execPath))!=-1&&console.warn(`subproc [${c}] still running.
getProcessInfoForPID returned:
${g}`)}D.strictEqual(s.exitCode,-1,`Should exit from signal (cmd.exitCode=-1) but got ${s.exitCode}`),D.strictEqual(ve,-1)}async function Ge(){const e=2;R||E("skipping OS-level process liveness checks (unsupported)"),await _e("standard",e),L.platform().startsWith("win")||await _e("group",e)}const R=(()=>{switch(L.platform()){case"darwin":case"freebsd":case"linux":case"openbsd":return"ps ax | awk '$1 == $PID { print $0 }'";case"aix":case"sunos":case"win32":return"";default:return""}})();function xe(e){return new Promise((t,r)=>{const s={},n=R.replace(/\$PID/,e);Ae.exec(n,s,(i,o,a)=>{t(o||"")})})}Ge().catch(e=>{console.error(e.stack||String(e)),process.exit(2)});
